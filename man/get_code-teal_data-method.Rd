% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/teal_data-get_code.R
\name{get_code,teal_data-method}
\alias{get_code,teal_data-method}
\alias{get_code}
\title{Get code from \code{teal_data} object}
\usage{
\S4method{get_code}{teal_data}(object, deparse = TRUE, datanames = NULL)
}
\arguments{
\item{object}{(\code{teal_data})}

\item{deparse}{(\code{logical}) flag specifying whether to return code as \code{character} (\code{deparse = TRUE}) or as
\code{expression} (\code{deparse = FALSE}).}

\item{datanames}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}} (\code{character}) vector of data set names to return the code for.}
}
\value{
Either string or an expression representing code used to create the requested data sets.
}
\description{
Retrieve code from \code{teal_data} object.
}
\details{
Retrieve code stored in \verb{@code}, which (in principle) can be used to recreate all objects found in \verb{@env}.
Use \code{datanames} to limit the code to one or more of the data sets enumerated in \verb{@datanames}.
If the code has not passed verification (with \code{\link[=verify]{verify()}}), a warning will be prepended.
}
\section{Extracting dataset-specific code}{

When \code{datanames} is specified \code{get_code} will limits the output only to the lines of code needed
to recreate the requested data sets. \code{code} stored in the \code{teal_data} object is analyzed statically
to determine dependency tree between each line of the code. Analysis is performed automatically
based on the used symbols and it is working in a standard case when a new dataset is created by
the assignment operator.

Consider the following example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{data <- teal_data() |>
  within(\{
    foo <- function(x) \{
      x + 1
    \}
    x <- 0
    y <- foo(x)
  \})
get_code(data, datanames = "y")
}\if{html}{\out{</div>}}

In above case \code{y} depends on \code{x} and \code{foo} so the code returned by \code{get_code(data, datanames = "y")}
will contain all three calls. \code{get_code(data, datanames = "x")} will return only the second call etc.
\cr
\code{get_code} isn't always able to properly assess dependencies between each calls and symbols in a
provided code. Consider the case where \code{y} depends on \code{x} but \code{x} is not created by assignment
operator. In such cases \code{get_code(data, datanames = "y")} will only return the last call:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{data <- teal_data() |>
  within(\{
    foo <- function() \{
      x <<- x + 1
    \}
    x <- 0
    foo()
    y <- x
  \})
get_code(data, datanames = "y")
}\if{html}{\out{</div>}}

To overcome limitation from above example, \code{get_code} allows to specify dependencies manually.
Adding \verb{# @linksto x} at the end of a line where unusual evaluation takes place will "flag"
this call as dependent on \code{x}.
NOTE: \code{expr} passed to \code{within} function discards comments. To add a code with comments to
\code{teal_data} object use \code{eval_code} function.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{data <- teal_data() |>
  eval_code("
    foo <- function() \{
      x <<- x + 1
    \}
    x <- 0
    foo() # @linksto x
    y <- x
  ")
get_code(data, datanames = "y")
}\if{html}{\out{</div>}}
}

\examples{

tdata1 <- teal_data()
tdata1 <- within(tdata1, {
  a <- 1
  b <- a^5
  c <- list(x = 2)
})
get_code(tdata1)
get_code(tdata1, datanames = "a")
get_code(tdata1, datanames = "b")

tdata2 <- teal_data(x1 = iris, code = "x1 <- iris")
get_code(tdata2)
get_code(verify(tdata2))
}
