% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cdisc_join_keys.R, R/join_keys.R
\name{cdisc_join_keys}
\alias{cdisc_join_keys}
\alias{join_keys}
\alias{join_keys.JoinKeys}
\alias{join_keys.teal_data}
\alias{join_keys.TealData}
\alias{join_keys.default}
\alias{join_keys<-}
\alias{join_keys<-.JoinKeys}
\alias{join_keys<-.teal_data}
\alias{[.JoinKeys}
\alias{[<-.JoinKeys}
\alias{[[.JoinKeys}
\alias{[[<-.JoinKeys}
\title{Create a \code{JoinKeys} out of a list of \code{join_key_set} objects}
\usage{
cdisc_join_keys(...)

join_keys(x = NULL, ...)

\method{join_keys}{JoinKeys}(x, ...)

\method{join_keys}{teal_data}(x, ...)

\method{join_keys}{TealData}(x, ...)

\method{join_keys}{default}(x, ...)

join_keys(join_keys_obj) <- value

\method{join_keys}{JoinKeys}(join_keys_obj) <- value

\method{join_keys}{teal_data}(join_keys_obj) <- value

\method{[}{JoinKeys}(join_keys_obj, dataset_1 = NULL, dataset_2 = NULL)

\method{[}{JoinKeys}(join_keys_obj, dataset_1, dataset_2 = dataset_1) <- value

\method{[[}{JoinKeys}(join_keys_obj, dataset_1 = NULL, dataset_2 = NULL, value)

\method{[[}{JoinKeys}(join_keys_obj, dataset_1 = NULL, dataset_2 = NULL) <- value
}
\arguments{
\item{...}{(optional), additional \code{join_key_set} objects when \code{x} is a \code{join_key_set}.
If argument types are mixed the call will fail.}

\item{x}{(optional), when no argument is given the empty constructor is called.
Otherwise, it can be one of: \code{JoinKeys}, \code{teal_data} or \code{join_key_set}.}

\item{join_keys_obj}{(\code{JoinKeys}) object to extract the join keys}

\item{value}{(\code{character} vector) value to assign.}

\item{dataset_1}{(\code{character}) name of first dataset.}

\item{dataset_2}{(\code{character}) name of second dataset.}
}
\value{
\code{JoinKeys} object.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
}
\details{
\code{cdisc_join_keys} is a wrapper around \code{join_keys} that sets the default
join keys for CDISC datasets. It is used internally by \code{cdisc_data} to
set the default join keys for CDISC datasets.

\itemize{
\item \code{join_keys()}: When called without arguments it will return an
empty constructor.
\item \code{join_keys(x)}: When called with a single argument it will return the \code{JoinKeys}
object contained in \code{x} (if it contains a \code{JoinKeys} object).
\item \code{join_keys(...)}: When called with a single or more \code{join_key_set} parameters it will
create a new object.
}

Note that join keys are created symmetrically, that is, if \code{dat1} and \code{dat2}
have a join key of \code{col1}, then 2 join keys are created, \verb{dat1 → dat2} and
\verb{dat2 → dat1}. The only exception is for a primary key.

The setter assignment \code{join_keys(obj) <- ...} will merge obj and \code{...} if obj
is not empty.

Getter for \code{JoinKeys} that returns the relationship between pairs of datasets.

Setter via index directly (bypassing the need to use \code{join_key()}).
When \code{dataset_2} is omitted, it will create a primary key with \code{dataset_2 = dataset_1}.
}
\examples{

# Default CDISC join keys

cdisc_join_keys(join_key("dataset_A", "dataset_B", c("col_1" = "col_a")), "ADTTE")
# Setting join keys ----

jk <- join_keys(
  join_key("dataset_A", "dataset_B", c("col_1" = "col_a")),
  join_key("dataset_A", "dataset_C", c("col_2" = "col_x", "col_3" = "col_y"))
)
jk

# or
jk <- join_keys()
jk["dataset_A", "dataset_B"] <- c("col_1" = "col_a")
jk["dataset_A", "dataset_C"] <- c("col_2" = "col_x", "col_3" = "col_y")
jk

td <- teal_data(join_keys = join_keys(join_key("a", "b", "c")))
join_keys(td)

jk <- join_keys()
join_keys(jk)

jk <- join_keys()
jk <- join_keys(join_key("a", "b", "c"))
jk <- join_keys(join_key("a", "b", "c"), join_key("a", "b2", "c"))

# Using the setter (assignment) ----

jk <- join_keys()
join_keys(jk) <- join_key("ds1", "ds2", "some_col")
join_keys(jk) <- join_key("ds3", "ds4", "some_col2")
join_keys(jk)["ds1", "ds3"] <- "some_col3"
jk

# Setter for JoinKeys within teal_data ----

td <- teal_data()
join_keys(td)["ds1", "ds2"] <- "key1"
join_keys(td)["ds2", "ds2"] <- "key2"
join_keys(td) <- join_keys(join_key("ds3", "ds2", "key3"))
join_keys(td)

# Getter for JoinKeys ----

jk <- join_keys()
join_keys(jk) <- join_key("ds1", "ds2", "some_col")
jk["ds1"]
jk[dataset_2 = "ds1"]
jk[1:2]
jk[c("ds1", "ds2")]

# Double subscript
jk["ds1", "ds2"]

# Setter via index ----

jk <- join_keys()
join_keys(jk) <- join_key("ds1", "ds2", "(original) pair key")

# overwrites previously defined key
jk["ds1", "ds2"] <- "(new) pair key"

# Creates primary key by only defining `dataset_1`
jk["ds1"] <- "primary_key"
jk

jk <- join_keys(join_key("ds1", "ds2", "key"))
jk[["ds1"]]
jk[["ds1", "ds2"]]

jk <- join_keys()
jk[["ds1"]] <- list()
jk[["ds2"]][["ds3"]] <- "key"
jk[["ds3", "ds4"]] <- "new_key"

jk <- join_keys()
jk[["ds1"]] <- list()
jk[["ds2"]][["ds3"]] <- "key"
jk[["ds4"]] <- list(ds5 = "new")
jk[["ds6", "ds7"]] <- "yada"
jk[["ds8", "ds9"]] <- c(A = "B", "C")
}
