% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join_keys.R, R/join_keys-c.R,
%   R/join_keys-extract.R, R/join_keys-print.R
\name{join_keys}
\alias{join_keys}
\alias{[[<-.join_keys}
\alias{join_keys.teal_data}
\alias{c.join_keys}
\alias{[.join_keys}
\alias{format.join_keys}
\alias{print.join_keys}
\alias{join_keys.default}
\alias{join_keys.join_keys}
\alias{join_keys.TealData}
\alias{join_keys<-}
\alias{join_keys<-.join_keys}
\alias{join_keys<-.teal_data}
\alias{c.join_key_set}
\alias{[<-.join_keys}
\title{Manage relationships between datasets using \code{join_keys}}
\usage{
join_keys(...)

\method{[[}{join_keys}(x, i) <- value

\method{join_keys}{teal_data}(...)

\method{c}{join_keys}(...)

\method{[}{join_keys}(x, i, j)

\method{format}{join_keys}(x, ...)

\method{print}{join_keys}(x, ...)

\method{join_keys}{default}(...)

\method{join_keys}{join_keys}(...)

\method{join_keys}{TealData}(...)

join_keys(x) <- value

\method{join_keys}{join_keys}(x) <- value

\method{join_keys}{teal_data}(x) <- value

\method{c}{join_key_set}(...)

\method{[}{join_keys}(x, i, j) <- value
}
\arguments{
\item{...}{(optional), when no argument is given the empty constructor is called.
Otherwise, when called with only one argument of type: \code{join_keys} or  \code{teal_data}
it will return the \code{join_keys} of that object.
When called with 1 or more \code{join_key_set} it will create a new \code{join_keys} with
constructed from the arguments.}

\item{x}{(\code{join_keys}) empty object to set the new relationship pairs.}

\item{i}{index specifying elements to extract or replace. Index should be a
a character vector, but it can also take numeric, logical, \code{NULL} or missing.}

\item{value}{(\code{join_key_set} or list of \code{join_key_set}) relationship pairs to add
to \code{join_keys} list.}

\item{j}{index specifying elements to extract or replace. Index should be a
a character vector, but it can also take numeric, logical, \code{NULL} or missing.}
}
\value{
\code{join_keys} object.
}
\description{
\code{join_keys()} facilitates the creation and retrieval of relationships between datasets.
\code{join_keys} class extends a list and contains keys connecting pairs of datasets. Each element
of the list contains keys for specific dataset. Each dataset can have a relationship with
itself (primary key) and with other datasets.

Note that \code{join_keys} list is symmetrical, that is, when keys are set between \code{dat1} and \code{dat2} it
is automatically mirrored between \code{dat2} and \code{dat1}.
}
\details{
\itemize{
\item \code{join_keys()}: Returns an empty \code{join_keys} object when called without arguments.
\item \code{join_keys(x)}: Returns the \code{join_keys} object contained in \code{x} (if it contains one).
\item \code{join_keys(...)}: Creates a new object with one or more \code{join_key_set} parameters.
\item \code{join_keys[datanames]}: Returns a subset of the \code{join_keys} object for given datanames,
including their symmetric mirror keys.
\item \code{join_keys[i, j]}: Returns join keys between datasets \code{i} and \code{j},
including implicit keys inferred from their relationship with a parent.
}

\itemize{
\item \verb{[[<-} is the preferred method to replace or assign new relationship pair to an
existing \code{join_keys} object.
\item \code{join_keys(obj)[[dataset_1]] <- value} can also be used to assign a relationship
pair to an \code{obj} that contains a \code{join_keys}, such as itself or a \code{teal_data}
object.
}

\itemize{
\item \verb{[.join_keys} can be used to return a subset of relationship pairs. It will
retrieve the primary keys of the selected elements and its parents (along with)
the relationship keys between the selected elements and their parents.
}

\itemize{
\item "\code{join_keys(obj) <- value}" will set the \code{join_keys} in object with \code{value}.
\code{value} needs to be an object of class \code{join_keys} or \code{join_key_set}.
}

\itemize{
\item \verb{[<-} is not a supported operation for \code{join_keys}.
}
}
\examples{
# Setting join keys ----

jk <- join_keys(
  join_key("ds1", "ds1", "pk1"),
  join_key("ds2", "ds2", "pk2"),
  join_key("ds3", "ds3", "pk3"),
  join_key("ds2", "ds1", c(pk2 = "pk1")),
  join_key("ds3", "ds1", c(pk3 = "pk1"))
)

jk

jk <- join_keys()
jk[["dataset_A"]][["dataset_B"]] <- "key"
jk[["dataset_C"]] <- list(dataset_A = "key_2", dataset_B = "key_3")
jk[["dataset_A"]][["dataset_C"]] <- NULL # removes key

jk
# Using a `join_keys` with `teal_data`

td <- teal_data()
join_keys(td) <- join_keys(
  join_key("ds1", "ds1", "pk1"),
  join_key("ds2", "ds2", "pk2"),
  join_key("ds3", "ds3", "pk3"),
  join_key("ds2", "ds1", c(pk2 = "pk1")),
  join_key("ds3", "ds1", c(pk3 = "pk1"))
)
join_keys(td)

# Merging multiple `join_keys`

jk_merged <- c(jk, join_keys(join_key("dataset_D", "dataset_E", "col_2")))

# Getter for join_keys ----

jk <- join_keys(
  join_key("ds1", "ds1", "primary-key-1"),
  join_key("ds2", "ds2", "primary-key-2"),
  join_key("ds3", "ds3", "primary-key-3"),
  join_key("ds2", "ds1", "foreign-key-2-1"),
  join_key("ds3", "ds1", "foregin-key-3-1")
)

jk["ds1"]
jk[1:2]
jk[c("ds1", "ds2")]
jk["ds1", "ds2"]

# Using the setter (assignment) ----
jk <- join_keys()
jk["ds1", "ds1"] <- "pk1"
jk["ds2", "ds2"] <- "pk2"
jk["ds3", "ds3"] <- "pk3"
jk["ds2", "ds1"] <- c(pk2 = "pk1")
jk["ds3", "ds1"] <- c(pk3 = "pk1")

# Setter for join_keys within teal_data ----

td <- teal_data()
join_keys(td)["ds1", "ds2"] <- "key1"
join_keys(td) <- c(join_keys(td), join_keys(join_key("ds3", "ds2", "key3")))
join_keys(td)

# Note that you can merge join_keys or a single join_key_set

jk_merged <- c(
  jk_merged,
  join_key("dataset_A", "dataset_F", "col_a"),
  join_key("dataset_O", "dataset_G", "col_g")
)
}
