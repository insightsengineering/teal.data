---
title: "Join Keys"
author: "NEST CoreDev"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Join Keys}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

The `teal.data` package provides a way to define primary keys for a dataset and establish relationships with other datasets.

Each dataset can be characterized by:

- Columns constituting the primary key
- Merge keys, analogous to `SQL` foreign keys

Typically, an application developer manually specifies these keys. However, for datasets following the `ADaM` standard, `teal.data` can automatically assign keys using the `default_cdisc_join_keys` object.
Refer to the section ["`ADaM` `join_keys`"](#adam-join_keys) for details on using this object to select specific datasets.

##### Uses of _join_keys_ in _teal_ applications

The primary function of `join_keys` in `teal` applications is to facilitate the seamless [merging of datasets](https://insightsengineering.github.io/teal.transform/latest-tag/articles/data-merge.html) using `teal.transform`.

Additionally, it plays a role on the data filtering using the _[Filter Panel](https://insightsengineering.github.io/teal/main/articles/filter-panel.html)_ in a `teal` application.
The filtering of a _(parent)_ dataset triggers additional background actions that will look for all datasets in which foreign keys target that _parent_ and then filter those accordingly.

## Anatomy of Join Keys

A new `join_keys` can be created by defining a set of primary and foreign keys. 
The `join_keys` object can also be extended by establishing parent-child relationships between datasets and adding/modifying/removing keys.

The `join_keys` function is used to specify keys:

- `join_keys(...)` is a collection of multiple `join_key` entries
- `join_key(...)` specifies the relation between two datasets:
  - `dataset_1`, `dataset_2`: names of the datasets (if `dataset_2` is the same as `dataset_1`, it creates a primary key)
  - `key` (optional): named vector of column names

_Note_ that join keys are assumed to be symmetric, i.e., `join_key("x", "y", c("x_col" = "y_col"))` establishes a relationship from "x" to "y and vice versa.

```{r, results="hide", message=FALSE, tidy=FALSE}
library(teal.data)
jk <- join_keys(
  join_key("ds1", keys = "col_1"),                    # ds1: [col_1]
  join_key("ds2", keys = c("col_1", "col_2")),        # ds2: [col_1, col_2]
  join_key("ds3", keys = c("col_1", "col_3")),        # ds3: [col_1, col_3]
  join_key("ds1", "ds2", keys = "col_1"),             # ds1 <--> ds2
  join_key("ds1", "ds3", keys = "col_1"),             # ds1 <--> ds3
  join_key("ds4", "ds5", keys = c("col_4" = "col_5")) # ds4 <--> ds5
)

# The parent of ds2 and ds3 is ds1
# converts relationship to child-parent
#  ds1 <--> ds2 becomes ds1 <-- ds2
#  ds1 <--> ds3 becomes ds1 <-- ds3
parents(jk) <- list(ds2 = "ds1", ds3 = "ds1")

jk

```

| Output of `print(jk)`              | Output annotation                    |
| ---------------------------------- |:----------------------------------------:|
| `## A join_keys object containing foreign keys between 3 datasets:` |  **Title** |
| `## ds1: [col_1]`                |  **Primary keys**<br />_\<dataset name\>_: [_\<primary_keys\>_]                                          | 
| `##   <-- ds2: [col_1]`          | **Foreign keys**<br /> _(arrow `<--` denotes `ds1` is the parent of `ds2`)_                    | 
| `##   <-- ds3: [col_1]`          |                                                                               | 
| `## ds2: [col_1, col_2]`           |                                                                               | 
| `##   --> ds1: [col_1]`          | arrow `-->` denotes `ds2` is a child of `ds1`                                                                              | 
| `##   --* (implicit via parent with): ds3` |  **Implicit relationship between `ds2` & `ds3`**<br />_(given that they share common keys with same parent)_    |
| `## ds3: [col_1, col_3]`           |                                                                               | 
| `##   --> ds1: [col_1]`          |                                                                               | 
| `##   --* (implicit via parent with): ds2` |                                                                               | 
| `## ds4: [no primary keys]`    |                                                                               | 
| `##   <-> ds5: [col_5]`          |  **Foreign keys** <br />_(arrow `<->` denotes no parent definition between datasets)_      | 
| `## ds5: [no primary keys]`    |                                                                               | 
| `##   <-> ds4: [col_4] `         |                                                                               | 

## Accessing and Modifying keys

The `join_keys` object behaves like a list and the preferred method to get a specific key to use the _subset_ operator with 2 indices. 

```{r}
# Using the jk object defined on "Anatomy of Join Keys"
jk

# Getting primary key of "ds1"
jk["ds1", "ds1"]

# Getting foreign keys between "ds2" and "ds1"
jk["ds4", "ds5"]

# Note the symmetry on the keys
jk["ds5", "ds4"]
```

Modifying or adding a key uses the same notation with the assignment operator `<-`. This will ensure symmetry as it will create both relationships. Assigning `NULL` value will delete the relation.

```{r}
# Adding a new ds5 <-> ds1 key
jk["ds5", "ds1"] <- "a_column"

# Removing an existing key
jk["ds4", "ds5"] <- NULL
```

## Join Keys Relationships

There are 2 types of relationships encoded with `join_keys` described in the following sections. The _primary_ and _foreign_ keys are created explicitly using the `join_key` function.

Additionally, the `join_keys` object detects implicit relationships when two datasets share foreign keys to a parent dataset, but not between themselves. These implicit relations are available just like another foreign key and can be used to merge datasets, despite not being defined by the user.

### Primary Key with _teal_data_

When using the `teal_data` function, the simplest method to define the join keys  is to use the `join_keys` argument.
We can specify the column(s) of the dataset that _(together)_ uniquely identify rows in the dataset.

```{r, include=FALSE}
# nolint start: commented_code_linter.
```

```{r, message=FALSE}
library(teal.data)
library(dplyr)

td_pk <- within(
  teal_data(),
  ds1 <- mutate(iris, id = factor(row_number()))
)
datanames(td_pk) <- c("ds1")

join_keys(td_pk) <- join_keys(join_key("ds1", keys = "id"))

join_keys(td_pk)
```

We can extend the previous example and define primary keys for multiple datasets:

```{r, message=FALSE}
library(teal.data)

td_pk <- within(
  td_pk,
  {
    ds2 <- data.frame(W = 10:1, V = 5:14, M = rep(1:5, 2))
    ds3 <- data.frame(V = 5:14, N = 4)
  }
)
datanames(td_pk) <- c(datanames(td_pk), "ds2", "ds3")

join_keys(td_pk)["ds2", "ds2"] <- c("V", "W")
join_keys(td_pk)["ds3", "ds3"] <- c("V", "W")

join_keys(td_pk)
```

```{r, include=FALSE}
# nolint end: commented_code_linter.
```

### Foreign Keys with _teal_data_

When passing multiple datasets to the `teal_data` function, dataset relationships are set using `join_keys` and `join_key` and these are used to merge datasets together within `teal` apps.
For users familiar with `SQL` database schema, these relationships are symmetric and not as strict as `SQL` foreign key relationships as `teal` does not validate whether the values inserted into foreign key columns are present in the parent table.

For example:

```{r}
library(teal.data)

td_fk <- within(
  teal_data(),
  {
    ds1 <- data.frame(X = 1:10, Y = 21:30, Z = 1:10)
    ds2 <- data.frame(W = 10:1, V = 5:14, M = rep(1:5, 2))
    ds3 <- data.frame(V = 5:14, N = 4)
  }
)
datanames(td_fk) <- c("ds1", "ds2", "ds3")

join_keys(td_fk) <- join_keys(
  # Primary keys
  join_key("ds1", keys = c("X")),
  join_key("ds2", keys = c("V", "W")),
  join_key("ds3", keys = c("V")),
  # Foreign keys
  join_key("ds2", "ds1", c("W" = "X")),
  join_key("ds3", "ds2", c("V" = "V"))
)

# The parent of ds2 and ds3 is ds1
parents(td_fk) <- list(ds2 = "ds1", ds3 = "ds2")

join_keys(td_fk)
```

### Implicit Relationships

This is a special inferred relationship from existing `join_keys` that does not need to be explicitly defined, however, as any other it can be overwritten.
If two datasets share common _foreign_ keys to the same _parent_ dataset, then there is an implicit relationship between them which is seamlessly accessible via the `join_keys` getter.

These implicit relationships can be used to merge 2 datasets together, just as if they were defined manually.

```{r}
library(teal.data)

td <- within(
  teal_data(),
  {
    ds1 <- data.frame(X = 1:10, Y = 21:30, Z = 1:10)
    ds2 <- data.frame(W = 10:1, V = 5:14, M = rep(1:5, 2))
    ds3 <- data.frame(V = 5:14, N = 4)
    ds4 <- data.frame(V = 5:14, R = rnorm(10))
  }
)
datanames(td) <- c("ds1", "ds2", "ds3", "ds4")

join_keys(td) <- join_keys(
  # Primary keys
  join_key("ds1", keys = c("X")),
  join_key("ds2", keys = c("V", "W")),
  join_key("ds3", keys = c("V")),
  join_key("ds4", keys = c("V")),
  # Foreign keys
  join_key("ds2", "ds1", c("W" = "X")),
  join_key("ds3", "ds2", c("V" = "V")),
  join_key("ds4", "ds1", c("V" = "X"))
)

# The parent of ds2 and ds3 is ds1
parents(td) <- list(ds2 = "ds1", ds3 = "ds2", ds4 = "ds1")

join_keys(td)

join_keys(td)["ds2", "ds4"]
```

_Note_ that the definition above contains no `join_key` for `"ds2" <-> "ds4"`

## _ADaM_ Join Keys

When working with datasets named according to the _ADaM_ standard, `teal.data` offers `default_cdisc_join_keys` object that contains primary and foreign keys for standard datasets.

```{r}
names(default_cdisc_join_keys) |> sort()
```

The full set of join keys can be used, or a subset of those.
Please note, that if the subsetted dataset has a parent, that will also be returned.

```{r}
default_cdisc_join_keys

default_cdisc_join_keys["ADSL"]

default_cdisc_join_keys["ADTTE"]

default_cdisc_join_keys[c("ADSL", "ADTTE", "ADRS")]
```
